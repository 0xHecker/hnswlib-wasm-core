{"version":3,"file":"hnswlib.js","sources":["../lib/constants.ts","../lib/index.ts"],"sourcesContent":["/***************** GENERATED FILE ********************/ \nexport const defaultParams = {\n  /**\n   * Default parameters for the HNSW index.\n   * @param {number} m The maximum number of outgoing connections on the graph (default: 16).\n   * @param {number} efConstruction The parameter that controls speed/accuracy trade-off during the index construction (default: 200).\n   * @param {number} randomSeed The seed value of random number generator (default: 100).\n   */\n  initIndex: [32, 128, 100],\n} as const;\n\nexport type defaultParamtersTypes = keyof typeof defaultParams;\n\nexport const hnswParamsForAda = {\n  m: 32,\n  efSearch: 128,\n  efConstruction: 128,\n  numNeighbors: 8,\n  dimensions: 1538,\n} as const;\n \n/***************** GENERATED FILE ********************/ \n","/***************** GENERATED FILE ********************/ \nimport type * as module from './hnswlib-wasm';\nimport type factory from './hnswlib-wasm';\n// import './hnswlib.mjs';\n\nexport type HierarchicalNSW = module.HierarchicalNSW;\nexport type BruteforceSearch = module.BruteforceSearch;\nexport type L2Space = module.L2Space;\nexport type InnerProductSpace = module.InnerProductSpace;\nexport type VectorFloat = module.VectorFloat;\nexport type VectorInt = module.VectorInt;\nexport type SearchResult = module.SearchResult;\n\nexport type HnswModuleFactory = typeof factory;\nexport type normalizePoint = HnswlibModule['normalizePoint'];\n\nexport * from './constants';\n\nexport interface HnswlibModule extends EmscriptenModule {\n  normalizePoint(vec: number[]): number[];\n  L2Space: new (dim: number) => module.L2Space;\n  InnerProductSpace: new (dim: number) => module.InnerProductSpace;\n  BruteforceSearch: new (space: 'l2' | 'ip' | 'cosine', dim: number) => module.BruteforceSearch;\n  HierarchicalNSW: new (space: 'l2' | 'ip' | 'cosine', dim: number) => module.HierarchicalNSW & {\n    readIndexFromBuffer: (buffer: Uint8Array) => void;\n    writeIndexToBuffer: () => Uint8Array;\n  };\n  VectorFloat: new () => module.VectorFloat;\n  VectorInt: new () => module.VectorInt;\n}\n\nlet library: HnswlibModule;\n\n/**\n * Load the HNSW library in node or browser\n */\nexport const loadHnswlib = async (): Promise<HnswlibModule> => {\n  try {\n    // @ts-expect-error - hnswlib can be a global variable in the browser\n    if (typeof hnswlib !== 'undefined' && hnswlib !== null) {\n      // @ts-expect-error - hnswlib can be a global variable in the browser\n      const lib = hnswlib();\n      if (lib != null) return lib;\n    }\n\n    if (!library) {\n      const factoryFunc = (await import('../lib/hnswlib.mjs')).default;\n      library = (await factoryFunc()) as HnswlibModule;\n    }\n    return library;\n  } catch (err) {\n    console.error('----------------------------------------');\n    console.error('Error initializing the library:', err);\n    throw err;\n  }\n};\n\n// disabled due to lack of perfomance improvemant and additional complexity\n\n// /**\n//  * Adds items and their corresponding labels to the HierarchicalNSW index using memory pointers.\n//  * This function handles the memory allocation for the Emscripten Module, and properly frees the memory after use.  its a wrapper around {@link HierarchicalNSW#addItemsWithPtrs}\n//  *\n//  * ⛔️ This function is only 1.02x faster than vectors for 10k points version which are easier to use.  The sole advantage is memory savings\n//  *\n//  * @async\n//  * @param {HnswlibModule} Module - The Emscripten HNSWLIB Module object.\n//  * @param {HierarchicalNSW} index - The HierarchicalNSW index object.\n//  * @param {Float32Array[] | number[][]} items - An array of item vectors to be added to the search index. Each item should be a Float32Array or an array of numbers.\n//  * @param {number[]} labels - An array of numeric labels corresponding to the items. The length of the labels array should match the length of the items array.\n//  * @param {boolean} replaceDeleted - A flag to determine if deleted elements should be replaced (default: false).\n//  * @returns {Promise<void>} A promise that resolves once the items and labels have been added to the index.\n//  */\n// export const addItemsWithPtrsHelper = async (\n//   Module: HnswlibModule,\n//   index: HierarchicalNSW,\n//   items: Float32Array[] | number[][],\n//   labels: number[],\n//   replaceDeleted: boolean\n// ): Promise<void> => {\n//   const itemCount = items.length;\n//   const dim = items[0].length;\n\n//   // Flatten the items array into a Float32Array\n//   const flatItems = new Float32Array(itemCount * dim);\n//   items.forEach((vec, i) => {\n//     flatItems.set(vec, i * dim);\n//   });\n\n//   // Convert labels to a Uint32Array\n//   const labelsArray = new Uint32Array(labels);\n\n//   const vecDataPtr = Module.asm.malloc(flatItems.length * Float32Array.BYTES_PER_ELEMENT);\n//   const labelVecDataPtr = Module.asm.malloc(labelsArray.length * Uint32Array.BYTES_PER_ELEMENT);\n\n//   if (vecDataPtr === 0) {\n//     throw new Error('Failed to allocate memory for vecDataPtr.');\n//   }\n\n//   if (labelVecDataPtr === 0) {\n//     throw new Error('Failed to allocate memory for labelVecDataPtr.');\n//   }\n\n//   Module.HEAPF32.set(flatItems, vecDataPtr / Float32Array.BYTES_PER_ELEMENT);\n//   Module.HEAPU32.set(labelsArray, labelVecDataPtr / Uint32Array.BYTES_PER_ELEMENT);\n\n//   await index.addItemsWithPtr(\n//     Module.HEAPF32.subarray(\n//       Math.floor(vecDataPtr / Float32Array.BYTES_PER_ELEMENT),\n//       Math.floor(vecDataPtr / Float32Array.BYTES_PER_ELEMENT) + itemCount * dim\n//     ),\n//     itemCount * dim,\n//     Module.HEAPU32.subarray(\n//       Math.floor(labelVecDataPtr / Uint32Array.BYTES_PER_ELEMENT),\n//       Math.floor(labelVecDataPtr / Uint32Array.BYTES_PER_ELEMENT) + itemCount\n//     ),\n//     itemCount,\n//     replaceDeleted\n//   );\n\n//   Module.asm.free(vecDataPtr);\n//   Module.asm.free(labelVecDataPtr);\n// };\n \n/***************** GENERATED FILE ********************/ \n"],"names":[],"mappings":"AACO,MAAM,aAAgB,GAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAO3B,SAAW,EAAA,CAAC,EAAI,EAAA,GAAA,EAAK,GAAG,CAAA;AAC1B,EAAA;AAIO,MAAM,gBAAmB,GAAA;AAAA,EAC9B,CAAG,EAAA,EAAA;AAAA,EACH,QAAU,EAAA,GAAA;AAAA,EACV,cAAgB,EAAA,GAAA;AAAA,EAChB,YAAc,EAAA,CAAA;AAAA,EACd,UAAY,EAAA,IAAA;AACd;;ACYA,IAAI,OAAA,CAAA;AAKG,MAAM,cAAc,YAAoC;AAC7D,EAAI,IAAA;AAEF,IAAA,IAAI,OAAO,OAAA,KAAY,WAAe,IAAA,OAAA,KAAY,IAAM,EAAA;AAEtD,MAAA,MAAM,MAAM,OAAQ,EAAA,CAAA;AACpB,MAAA,IAAI,GAAO,IAAA,IAAA;AAAM,QAAO,OAAA,GAAA,CAAA;AAAA,KAC1B;AAEA,IAAA,IAAI,CAAC,OAAS,EAAA;AACZ,MAAA,MAAM,WAAe,GAAA,CAAA,MAAM,OAAO,uBAAoB,CAAG,EAAA,OAAA,CAAA;AACzD,MAAA,OAAA,GAAW,MAAM,WAAY,EAAA,CAAA;AAAA,KAC/B;AACA,IAAO,OAAA,OAAA,CAAA;AAAA,WACA,GAAK,EAAA;AACZ,IAAA,OAAA,CAAQ,MAAM,0CAA0C,CAAA,CAAA;AACxD,IAAQ,OAAA,CAAA,KAAA,CAAM,mCAAmC,GAAG,CAAA,CAAA;AACpD,IAAM,MAAA,GAAA,CAAA;AAAA,GACR;AACF;;;;"}